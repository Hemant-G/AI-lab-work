# Tic-Tac-Toe AI using Alpha–Beta Pruning (C++)

## AIM

To implement the **Tic-Tac-Toe game** in C++ where the computer (AI) plays optimally using **Minimax with Alpha–Beta Pruning**.
The objective is to let a human player (`X`) compete against the AI (`O`), with the AI always making the best possible move while pruning unnecessary branches to optimize performance.


## Algorithm

### State Representation

Each game state is represented using the `state` class:

* `vector<vector<char>> board`: 3×3 game grid storing `'X'`, `'O'`, or `'-'` (empty).
* `char player`: Current player to move (`'X'` or `'O'`).


### Move Generation

* A move is generated by placing the current player's symbol (`X` or `O`) in an empty cell `board[row][col]`.
* After each move, the turn alternates to the other player.


### Evaluation Function

The function `evaluate(board)` returns:

* `+1` -> if `X` wins
* `-1` -> if `O` wins
* `0` -> if the game ends in a draw
* `2` -> if the game is still ongoing (moves available)


### Alpha–Beta Pruning Algorithm

1. **Terminal check**:

   * If the game is won, lost, or drawn -> return evaluation score.

2. **Maximizer (X)**:

   * Initialize `best = -1000`
   * For each valid move:

     * Generate next state
     * Recursively call `alpha_beta(next, 'O', alpha, beta)`
     * Update `best = max(best, value)`
     * Update `alpha = max(alpha, best)`
     * If `beta <= alpha` -> **prune remaining moves**

3. **Minimizer (O)**:

   * Initialize `best = 1000`
   * For each valid move:

     * Generate next state
     * Recursively call `alpha_beta(next, 'X', alpha, beta)`
     * Update `best = min(best, value)`
     * Update `beta = min(beta, best)`
     * If `beta <= alpha` -> **prune remaining moves**

4. **Best Move Selection**:
   The AI chooses the move that maximizes its chances of winning (if `X`) or minimizes them (if `O`) using the `find_best_move` function.


### Game Loop

* The game alternates turns between the human and AI until a terminal state is reached.
* Human inputs moves as numbers `1–9`.
* AI uses `find_best_move` to compute the optimal move using alpha–beta pruning.
* The board is printed after each move.
* At the end, the winner or draw is displayed.


## Complexity

* **State Space Size:** At most `9! = 362880` possible board configurations.
* **Time Complexity:** `O(b^d)`

  * `b` = branching factor ≈ number of available moves (max 9)
  * `d` = maximum depth = 9 moves
* **Space Complexity:**

  * Each recursive call stores a copy of the board -> `O(d)` recursion depth.
* **Efficiency:**

  * Alpha–beta pruning reduces the number of branches explored compared to plain Minimax, skipping branches that cannot affect the final decision.
