# Minimax Algorithm (Tic-Tac-Toe Game)

## AIM  

To implement the **Tic-Tac-Toe game** in C++ where the computer (AI) plays optimally using the **Minimax Algorithm**.  
The objective is to let a human player (`X`) compete against the AI (`O`), with the AI always making the best possible move.  

---

## Algorithm  

### State Representation  

Each game state is represented using the `state` class:  
- `vector<vector<char>> board`: 3×3 game grid storing `'X'`, `'O'`, or `'-'` (empty).  
- `char player`: Current player to move (`'X'` or `'O'`).  

### Move Generation  

- A move is generated by placing the current player's symbol (`X` or `O`) in an empty cell `board[row][col]`.  
- After each move, the player alternates.  

### Evaluation Function  

The function `evaluate(board)` returns:  
- `+1` → if `X` wins  
- `-1` → if `O` wins  
- `0` → if the game ends in a draw  
- `2` → if the game is still ongoing (moves available)  

### Minimax Algorithm  

1. **Terminal check**:  
   If the game is won, lost, or drawn → return evaluation score.  

2. **Maximizer (X)**:  
   - Initialize best = `-∞`  
   - For each valid move:  
     - Generate next state  
     - Recursively call `mini_max(next, 'O')`  
     - Update best = `max(best, value)`  

3. **Minimizer (O)**:  
   - Initialize best = `+∞`  
   - For each valid move:  
     - Generate next state  
     - Recursively call `mini_max(next, 'X')`  
     - Update best = `min(best, value)`  

4. **Best Move Selection**:  
   The AI chooses the move that maximizes its chances of winning (if `X`) or minimizes them (if `O`).  

---

## Complexity  

- **State Space Size:** At most `9! = 362,880` possible board configurations.  
- **Time Complexity:** `O(b^d)`  
  - `b = branching factor ≈ number of available moves (max 9)`  
  - `d = maximum depth = 9 moves`  
- In practice, Minimax prunes naturally because of winning conditions reached earlier.  

- **Space Complexity:**  
  - Each recursive call stores a copy of the board → `O(d)` recursion depth.  

---

